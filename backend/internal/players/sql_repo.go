package players

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/Germanicus1/kanban-sim/backend/internal/models"
	"github.com/google/uuid"
)

type sqlRepo struct {
	db *sql.DB
}

func (r *sqlRepo) CreatePlayer(ctx context.Context, gameID uuid.UUID, name string) (uuid.UUID, error) {
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return uuid.Nil, fmt.Errorf("begin tx: %w", err)
	}
	defer func() {
		if p := recover(); p != nil {
			tx.Rollback()
			panic(p)
		}
	}()

	var playerID uuid.UUID
	if err := tx.QueryRowContext(ctx,
		`INSERT INTO players (name, game_id)
			 VALUES ($1, $2)
		 RETURNING id`,
		name, gameID,
	).Scan(&playerID); err != nil {
		tx.Rollback()
		return uuid.Nil, fmt.Errorf("insert player: %w", err)
	}
	if err := tx.Commit(); err != nil {
		return uuid.Nil, fmt.Errorf("commit tx: %w", err)
	}
	if playerID == uuid.Nil {
		return uuid.Nil, fmt.Errorf("expected autogenerated player ID, got nil")
	}

	return playerID, nil
}

func (r *sqlRepo) GetPlayerByID(ctx context.Context, id uuid.UUID) (*models.Player, error) {
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("begin tx: %w", err)
	}
	defer func() {
		if p := recover(); p != nil {
			tx.Rollback()
			panic(p)
		}
	}()

	var player models.Player
	if err := tx.QueryRowContext(ctx,
		`SELECT id, name, game_id FROM players WHERE id = $1`,
		id,
	).Scan(&player.ID, &player.Name, &player.GameID); err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("player not found: %w", err)
		}
		tx.Rollback()
		return nil, fmt.Errorf("query player: %w", err)
	}
	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("commit tx: %w", err)
	}

	if player.ID == uuid.Nil {
		return nil, fmt.Errorf("expected player ID, got nil")
	}

	if player.Name == "" {
		return nil, fmt.Errorf("player name is empty")
	}

	if player.GameID == uuid.Nil {
		return nil, fmt.Errorf("player game ID is empty")
	}
	// If we reach here, it means the player was successfully retrieved
	return &player, nil
}

var ErrNotFound = errors.New("player not found")

func (r *sqlRepo) UpdatePlayer(ctx context.Context, id uuid.UUID, name string) error {
	const q = `UPDATE players SET name = $1 WHERE id = $2`
	result, err := r.db.ExecContext(ctx, q, name, id)
	if err != nil {
		return fmt.Errorf("update player: %w", err)
	}
	rows, _ := result.RowsAffected()
	if rows == 0 {
		return ErrNotFound
	}
	return nil
}

func (r *sqlRepo) DeletePlayer(ctx context.Context, id uuid.UUID) error {
	const q = `DELETE FROM players WHERE id = $1`

	res, err := r.db.ExecContext(ctx, q, id)
	if err != nil {
		return fmt.Errorf("delete player: %w", err)
	}

	n, err := res.RowsAffected()
	if err != nil {
		return fmt.Errorf("delete player (rows affected): %w", err)
	}
	if n == 0 {
		return ErrNotFound
	}

	return nil
}

func (r *sqlRepo) ListPlayersByGameID(ctx context.Context, gameID uuid.UUID) ([]*models.Player, error) {
	const q = `SELECT id, name, game_id FROM players WHERE game_id = $1`
	rows, err := r.db.QueryContext(ctx, q, gameID)
	if err != nil {
		return nil, fmt.Errorf("query players: %w", err)
	}
	defer rows.Close()

	players := make([]*models.Player, 0)

	for rows.Next() {
		var p models.Player
		if err := rows.Scan(&p.ID, &p.Name, &p.GameID); err != nil {
			return nil, fmt.Errorf("scan player: %w", err)
		}
		players = append(players, &p)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return players, nil
}
