package players_test

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"regexp"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/Germanicus1/kanban-sim/backend/internal/models"
	"github.com/Germanicus1/kanban-sim/backend/internal/players"
	"github.com/google/uuid"
	"github.com/stretchr/testify/require"
)

// CreatePlayer tests
func TestSQLRepo_CreatePlayer(t *testing.T) {
	const insertQuery = `INSERT INTO players (name, game_id, created_at) VALUES ($1, $2) RETURNING id`

	tests := []struct {
		name           string
		setupMock      func(m sqlmock.Sqlmock, expectedID uuid.UUID)
		wantErrContain string
	}{
		{
			name: "BeginTx error",
			setupMock: func(m sqlmock.Sqlmock, _ uuid.UUID) {
				m.ExpectBegin().
					WillReturnError(fmt.Errorf("boom"))
			},
			wantErrContain: "begin tx",
		},
		{
			name: "Insert error",
			setupMock: func(m sqlmock.Sqlmock, _ uuid.UUID) {
				m.ExpectBegin()
				m.
					ExpectQuery(regexp.QuoteMeta(insertQuery)).
					WithArgs("Alice", sqlmock.AnyArg()).
					WillReturnError(errors.New("insert failed"))
				m.ExpectRollback()
			},
			wantErrContain: "insert player",
		},
		{
			name: "Commit error",
			setupMock: func(m sqlmock.Sqlmock, expectedID uuid.UUID) {
				m.ExpectBegin()
				m.
					ExpectQuery(regexp.QuoteMeta(insertQuery)).
					WithArgs("Alice", sqlmock.AnyArg()).
					WillReturnRows(
						sqlmock.NewRows([]string{"id"}).
							AddRow(expectedID),
					)
				m.ExpectCommit().
					WillReturnError(fmt.Errorf("commit boom"))
			},
			wantErrContain: "commit tx",
		},
		{
			name: "Nil UUID returned",
			setupMock: func(m sqlmock.Sqlmock, _ uuid.UUID) {
				m.ExpectBegin()
				m.
					ExpectQuery(regexp.QuoteMeta(insertQuery)).
					WithArgs("Alice", sqlmock.AnyArg()).
					WillReturnRows(
						sqlmock.NewRows([]string{"id"}).
							AddRow(uuid.Nil),
					)
				m.ExpectCommit()
			},
			wantErrContain: "expected autogenerated player ID",
		},
		{
			name: "Success",
			setupMock: func(m sqlmock.Sqlmock, expectedID uuid.UUID) {
				m.ExpectBegin()
				m.
					ExpectQuery(regexp.QuoteMeta(insertQuery)).
					WithArgs("Alice", sqlmock.AnyArg()).
					WillReturnRows(
						sqlmock.NewRows([]string{"id"}).
							AddRow(expectedID),
					)
				m.ExpectCommit()
			},
			// wantErrContain empty means success path
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			db, mock, err := sqlmock.New()
			require.NoError(t, err)
			defer db.Close()

			repo := players.NewSQLRepo(db)

			// Generate a fresh expectedID for this sub-test
			expectedID := uuid.New()

			// Set up the mock for this scenario
			tc.setupMock(mock, expectedID)

			// Execute
			id, err := repo.CreatePlayer(
				context.Background(),
				models.Player{
					Name:   "Alice",
					GameID: uuid.New(),
				},
			)

			if tc.wantErrContain != "" {
				// Error cases always return uuid.Nil
				require.Equal(t, uuid.Nil, id)
				require.ErrorContains(t, err, tc.wantErrContain)
			} else {
				// Success: we must get exactly the expectedID back
				require.NoError(t, err)
				require.Equal(t, expectedID, id)
			}

			require.NoError(t, mock.ExpectationsWereMet())
		})
	}
}

// GetPlayerByID tests
func TestSQLRepo_GetPlayerByID(t *testing.T) {
	const query = `SELECT id, name, game_id FROM players WHERE id = $1`
	tests := []struct {
		name           string
		setupMock      func(mock sqlmock.Sqlmock, id uuid.UUID)
		wantErrContain string
		wantPlayer     *models.Player
	}{
		{
			name: "BeginTx error",
			setupMock: func(mock sqlmock.Sqlmock, id uuid.UUID) {
				mock.ExpectBegin().WillReturnError(errors.New("tx failed"))
			},
			wantErrContain: "begin tx",
		},
		{
			name: "No rows (ErrNoRows)",
			setupMock: func(mock sqlmock.Sqlmock, id uuid.UUID) {
				mock.ExpectBegin()
				mock.
					ExpectQuery(regexp.QuoteMeta(query)).
					WithArgs(id).
					WillReturnError(sql.ErrNoRows)
			},
			wantErrContain: "player not found",
		},
		{
			name: "QueryRowContext other error",
			setupMock: func(mock sqlmock.Sqlmock, id uuid.UUID) {
				mock.ExpectBegin()
				mock.
					ExpectQuery(regexp.QuoteMeta(query)).
					WithArgs(id).
					WillReturnError(errors.New("db oops"))
				mock.ExpectRollback()
			},
			wantErrContain: "query player",
		},
		{
			name: "Commit error",
			setupMock: func(mock sqlmock.Sqlmock, id uuid.UUID) {
				mock.ExpectBegin()
				mock.
					ExpectQuery(regexp.QuoteMeta(query)).
					WithArgs(id).
					WillReturnRows(
						sqlmock.NewRows([]string{"id", "name", "game_id"}).
							AddRow(id, "Alice", uuid.New()),
					)
				mock.ExpectCommit().WillReturnError(errors.New("boom"))
			},
			wantErrContain: "commit tx",
		},
		{
			name: "Nil ID after commit",
			setupMock: func(mock sqlmock.Sqlmock, id uuid.UUID) {
				mock.ExpectBegin()
				mock.
					ExpectQuery(regexp.QuoteMeta(query)).
					WithArgs(id).
					WillReturnRows(
						sqlmock.NewRows([]string{"id", "name", "game_id"}).
							AddRow(uuid.Nil, "Alice", uuid.New()),
					)
				mock.ExpectCommit()
			},
			wantErrContain: "expected player ID",
		},
		{
			name: "Empty name after commit",
			setupMock: func(mock sqlmock.Sqlmock, id uuid.UUID) {
				mock.ExpectBegin()
				mock.
					ExpectQuery(regexp.QuoteMeta(query)).
					WithArgs(id).
					WillReturnRows(
						sqlmock.NewRows([]string{"id", "name", "game_id"}).
							AddRow(id, "", uuid.New()),
					)
				mock.ExpectCommit()
			},
			wantErrContain: "player name is empty",
		},
		{
			name: "Empty gameID after commit",
			setupMock: func(mock sqlmock.Sqlmock, id uuid.UUID) {
				mock.ExpectBegin()
				mock.
					ExpectQuery(regexp.QuoteMeta(query)).
					WithArgs(id).
					WillReturnRows(
						sqlmock.NewRows([]string{"id", "name", "game_id"}).
							AddRow(id, "Alice", uuid.Nil),
					)
				mock.ExpectCommit()
			},
			wantErrContain: "player game ID is empty",
		},
		{
			name: "Success",
			setupMock: func(mock sqlmock.Sqlmock, id uuid.UUID) {
				mock.ExpectBegin()
				expectedName := "Alice"
				expectedGameID := uuid.New()
				mock.
					ExpectQuery(regexp.QuoteMeta(query)).
					WithArgs(id).
					WillReturnRows(
						sqlmock.NewRows([]string{"id", "name", "game_id"}).
							AddRow(id, expectedName, expectedGameID),
					)
				mock.ExpectCommit()
			},
			wantPlayer: &models.Player{
				// only ID/Name/GameID matter for this test
				ID:     uuid.Nil, // overwritten in assertion
				Name:   "",       // overwritten
				GameID: uuid.Nil, // overwritten
			},
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			db, mock, err := sqlmock.New()
			require.NoError(t, err)
			defer db.Close()

			repo := players.NewSQLRepo(db)
			id := uuid.New()
			tc.setupMock(mock, id)

			player, err := repo.GetPlayerByID(context.Background(), id)

			if tc.wantPlayer != nil {
				// success path
				require.NoError(t, err)
				require.NotNil(t, player)
				require.Equal(t, id, player.ID)
				require.Equal(t, player.Name, player.Name)     // name was set in mock
				require.Equal(t, player.GameID, player.GameID) // game_id set in mock
			} else {
				// error paths
				require.Nil(t, player)
				require.ErrorContains(t, err, tc.wantErrContain)
			}

			require.NoError(t, mock.ExpectationsWereMet())
		})
	}
}

func TestSQLRepo_UpdatePlayer(t *testing.T) {
	const updateQuery = `UPDATE players SET name = $1 WHERE id = $2`
	tests := []struct {
		name           string
		setupMock      func(mock sqlmock.Sqlmock, id uuid.UUID, name string)
		wantErrContain string
	}{
		{
			name: "ExecContext error",
			setupMock: func(mock sqlmock.Sqlmock, id uuid.UUID, name string) {
				mock.ExpectExec(regexp.QuoteMeta(updateQuery)).
					WithArgs(name, id).
					WillReturnError(errors.New("db down"))
			},
			wantErrContain: "update player",
		},
		{
			name: "No rows affected",
			setupMock: func(mock sqlmock.Sqlmock, id uuid.UUID, name string) {
				mock.ExpectExec(regexp.QuoteMeta(updateQuery)).
					WithArgs(name, id).
					WillReturnResult(sqlmock.NewResult(0, 0))
			},
			wantErrContain: "player not found",
		},
		{
			name: "Success",
			setupMock: func(mock sqlmock.Sqlmock, id uuid.UUID, name string) {
				mock.ExpectExec(regexp.QuoteMeta(updateQuery)).
					WithArgs(name, id).
					WillReturnResult(sqlmock.NewResult(1, 1))
			},
			// wantErrContain empty means success path
		},
	}
	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			db, mock, err := sqlmock.New()
			require.NoError(t, err)
			defer db.Close()

			repo := players.NewSQLRepo(db)
			id := uuid.New()
			name := "Bob"

			tc.setupMock(mock, id, name)

			err = repo.UpdatePlayer(context.Background(), id, name)

			if tc.wantErrContain != "" {
				require.ErrorContains(t, err, tc.wantErrContain)
			} else {
				require.NoError(t, err)
			}

			require.NoError(t, mock.ExpectationsWereMet())
		})
	}
}
